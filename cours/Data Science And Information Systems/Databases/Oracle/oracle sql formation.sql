
-- SELECT STATEMENT
-- BASIC SELECT STATEMENT

-- SELECT {*|[DISTINCT] column|expression [alias],....} FROM TABLE ;

-- to select all the columns/ rows in table use :

	SELECT * FROM departments;

-- to select specific columns

	SELECT DEPRTMENT_ID, DEPARTMENTS_NAME FROM DEPARTMENTS;

-- using arthmetic expressions + - * /

	SELECT SALARY, SALARY+100, SALARY+(SALARY*0.1) FROM employees;

-- to know null values : value that is unavailable

	SELECT last_name, job_if, salary, commission_pct FROM employees;

-- defining a column alias

    select last_name, last_name as name, last_name name, last_name “last name” from employees;

-- concatenation operator || links columns or character strings

	SELECT FIRST_NAME, FIRST_NAME || LAST_NAME "FULL NAME", 
	FIRST_NAME || ' ' || LAST_NAME "full name with space" -- using literal charcter strings
	FROM
	employees;

	SELECT FIRST_NAME || ' work in department' || DEPARTMENT_ID example 
	FROM
	EMPLOYEES;

	SELECT FIRST_NAME ||q'[work in department]'|| DEPRTMENT_ID 
	FROM
	EMPLOYEES;

-- using distinct

	SELECT  DISTINCT DEPRTMENT_ID FROM EMPLOYEES;

-- many columns in distinct

    SELECT DISTINCT DEPARTMENT_ID, DEPARTMENTS_NAME FROM EMPLOYEES;

-- DESCRIBE OR DESC COMMAND 
-- USE TO DISPALY THE STRUCTURE OF A TABLE

    DESCRIBE EMPLOYEES;
    DESC EMPLOYEES;


--- limitinfg the rows the are selected "WHERE"

SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID=90;

SELECT EMPLOYEE_ID  FROM EMPLOYEES WHERE FIRST_NAME='Steven';

SELECT * FROM EMPLOYEES WHERE HIRE_DATE='10-OCT-1990';
-- COMPARISON OPERATORS

=
>
>=
<
<=
<> 'not equal'
BETWEEN ... AND .... 
IN(set)
LIKE
IS NULL

SELECT * FROM EMPLOYEES WHERE SALARY IN (10000, 250000, 170000); -- THE ORDER IS NOT IMPORTANT

-- LIKE

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'S%' -- ALL THE FIRST NAME WHICH START WITH S

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'%S' -- END WITH S

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'%am%' -- WICH INCLUDE am

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'_D%' -- WHICH HAS D THE SECOND LETTER  

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'%__S%' -- S IN THIRD LETTER

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'SA_%'

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'SA/_% ' escape '/';

SELECT * FROM EMPLOYESS WHERE FIRST_NAME LIKE'%/%% ' escape '/';

SELECT * FROM EMPLOYESS WHERE COMISSION_PCT IS NULL;

SELECT * FROM EMPLOYESS WHERE EMPLOYEE_ID NOT IN (100, 101);

SELECT * FROM EMPLOYESS WHERE COMISSION_PCT IS NOT NULL;

SELECT * FROM EMPLOYESS WHERE FIRST_NAME  NOT LIKE '%S';

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID WHERE SALARY >= 10000 AND DEPARTMENT_ID = 90;

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID WHERE SALARY >= 10000 OR DEPARTMENT_ID = 90;

SELECT LAST_NAME, JOB_ID, SALARY FROM EMPLOYEES 
WHERE JOB_ID ='SA_REP'
OR
(JOB_ID = 'AD_PRES' AND SALARY > 150000);


SELECT LAST_NAME, JOB_ID, SALARY FROM EMPLOYEES 
WHERE 
(JOB_ID ='SA_REP'OR JOB_ID = 'AD_PRES')
 AND SALARY > 150000;


-- ORDER BY

SELECT * FROM EMPLOYEESS
ORDER BY HIRE_DATE;

SELECT * FROM EMPLOYEESS
ORDER BY HIRE_DATE ASC; 

SELECT * FROM EMPLOYEESS
ORDER BY HIRE_DATE DESC;

SELECT * FROM EMPLOYEESS
WHERE DEPRTMENT_ID=90
ORDER BY EMPLOYEE_ID;

SELECT * FROM EMPLOYEESS
ORDER BY COMISSON_PCT; -- null come last ascending order

SELECT FIRST_NAME n 
FROM EMPLOYEES
ORDER BY n; -- YOU CAN SORT ASLO COLUMN ALIAS

SELECT EMPLOYES_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID;

SELECT EMPLOYES_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, FIRST_NAME;

SELECT EMPLOYES_ID, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID ASC, FIRST_NAME DESC;

SELECT EMPLOYES_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY 1; -- 1 MEAN THE FIRST COLUMN IN SELECT WHICH IS THE DEPARTMENT_ID

SELECT EMPLOYES_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY 1, 3; 

-- FETCH 12c  SORTING VIDEO 13  PART 4


-- SUBSTITUTION VARIBALE 

SELECT EMPLOYEE_ID, LAST_NAME, SALARY 
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_NUM; 

-- USE '' WHEN VARCHAR


SELECT EMPLOYEE_ID, LAST_NAME, SALARY 
FROM EMPLOYEES
WHERE EMPLOYEE_ID = '&NAME' ORDER BY 2; 

SELECT EMPLOYEE_ID, LAST_NAME, SALARY, &COLUMN_NAME
FROM EMPLOYEES
WHERE EMPLOYEE_ID =&CONSITION
ORDER BY &ORDER_COLUMN; 


 -- USE THE DEFINECOMMAND TO CREATE AND ASSGIN A VALUE A VARIBALE
 -- USE THE UNDEFIN COMMAND TO REMOVE A VARIABLE


 DEFINE EMPLOYEE_NUM = 200;

SELECT EMPLOYEE_ID, LAST_NAME, SALARY 
FROM EMPLOYEES
WHERE EMPLOYEE_ID = &EMPLOYEE_NUM; 


UNDEFINE EMPLOYEE_NUM;

--- YOU CAN CHANGE THE PROMPT MESSAGE AS FOLLOW
-- BUT IT SHOULD EXECTED AS SCRIPT

ACCEPT DEPT_ID PROMPT 'PLEASE ENTER DEPT ID';
SELECT * FROM EMPLOYEESWHERE  DEPARTMENT_ID=&DEPT_ID;

UNDEFINE DEPT_ID;

-- THE && DEFINE THE VARBLE AND ASSGIN THE VALUE IN THE SAME TIME, THEN YOU CAN  RE-USE AGAIN

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, &&COLUMN_NAME
FROM EMPLOYEES
ORDER BY &COLUMN_NAME;

UNDEFINE COLUMN_NAME;


-- VERIFY

SET VERIFY ON  -- VARIABLE BEFORE AND AFTER SHOW DETAILS 9ABLA WA BA3DA
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID
FROM EMPLOYEES
WHERE &COLUMN_ID=100;

SET DEFINE OFF;
SET DEFINE ON;


-- --- CHARCTER FUNCTIONS ----

-- UPPER, LOWER, INITCAP

SELECT  EMPLOYEE_ID,FIRST_NAME, UPPER(FIRST_NAME), LOWER(FIRST_NAME), INITCAP(FIRST_NAME) -- INITCAP FIRST CHARACTER LOWER
FROM EMPLOYEES;

-- SINGLE ROW FUNCTION CAN BE USED IN SELECT, WHERE, ORDER BY

SELECT  EMPLOYEE_ID,FIRST_NAME, UPPER(FIRST_NAME), LOWER(FIRST_NAME), INITCAP(FIRST_NAME) -- INITCAP FIRST CHARACTER LOWER
FROM EMPLOYEES
WHERE UPPER(FIRST_NAME)='PATRICK';


SELECT  EMPLOYEE_ID,FIRST_NAME, UPPER(FIRST_NAME), LOWER(FIRST_NAME), INITCAP(FIRST_NAME) -- INITCAP FIRST CHARACTER LOWER
FROM EMPLOYEES
WHERE UPPER(FIRST_NAME)='PATRICK'
ORDER BY UPPER(FIRST_NAME); -- THIS EXAMPLE PERFECT WHEN CREATING SEARCH SCREEN 


--- CONCAT

SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, CONCAT(FIRST_NAME,LAST_NAME)
FROM EMPLOYEES; -- THE CONCAT FUNCTION ONLY LOOK 2 ARGS BUT || MORE FLIXABL


SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, FIRST_NAME||' '||LAST_NAME||SALARY name
FROM EMPLOYEES;

-- SUBSTR FUNCTION

-- SUBSTR (COLUMN|EXPRESION, M,N)
-- M IS THE STARTING POSITION, N THE CHARACTERS LONG

SELECT EMPLOYEES_ID, 
FIRST_NAME,
SUBSTR(FIRST_NAME,1,3),
SUBSTR(FIRST_NAME,2,4),
SUBSTR(FIRST_NAME,2), -- IF YOU DONT SPECIFY THE N VALUE
SUBSTR(FIRST_NAME,-3)-- THE COUNT START FROM THE END
FROM EMPLOYEES;

-- LENGTH FUNCTION 

SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES; -- IT TAKE CHAR AND RETURN NUMBER

-- ---------- INSTR FUNCTION ----------------------------------------------------------

--- INSTR(COLUMN,m,n)
-- m IS THE START SEARCHING POSITION, n THE OCCOURENCE

SELECT EMPLOYEES_ID, 
FIRST_NAME,
INSTR(FIRST_NAME,'e'),
INSTR(FIRST_NAME,'e',2),
INSTR(FIRST_NAME,'e',5), -- 
INSTR(FIRST_NAME,'e',1,2)-- SECAND SEARCH
FROM EMPLOYEES
WHERE FIRST_NAME='Nanette';

----------------------- LPAD AND RPAD ---------------------------------

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, LPAD(SALARY,10,'#'), RPAD(SALARY,10,'*')
FROM EMPLOYEESS;

---------------- REPLACE FUNCTION ----------------------------------

SELECT EMPLOYEE_ID, FIRST_NAME, REPLACE(FIRST_NAME,'a','*'),REPLACE(FIRST_NAME,'en',#)
FROM EMPLOYEES;


----------------- TRIM FUNCTION ----------------------------

SELECT *FROM DUAL; -- SO IT IS TABLE CONTAIN ONE COLUMN AND ONY DUMMY VALUE X

SELECT 1+1 FROM DUAL;

-- TRIM ( [LEADING | TRALING | BOTH] trim_CHARACTER FROM ] DTRING1 )

SELECT TRIM (' ' FROM ' KHALED KHUDARI ') V FROM DUAL;

SELECT TRIM (LEADING ' ' FROM ' KHALD ') V FROM DUAL; -- DELET SPACE FROM START


SELECT TRIM (TRAILING ' ' FROM ' KHALD ') V FROM DUAL; -- DELET SPACE FROM END

SELECT TRIM (BOTH ' ' FROM ' KHALD ') V FROM DUAL; -- DELET SPACE FROM START  AND END -- BY DALFAUL BOTH

SELECT TRIM ('k' FROM 'KHALD KHOUDARI') V FROM DUAL;

SELECT TRIM (' KHALID KHOUKHOU ') V FROM DUAL; -- BY DEFUALT DELET SPACE FROM STAR AND END



--------------- NUMBER FUNCTION --------------------------------------------- 

SELECT ROUND(10.5) FROM DUAL; -- RETURN 11

SELECT ROUND(150.49) FROM DUAL; -- RETURN 150

SELECT ROUND(10.48, 1) FROM DUAL; -- 10.5

SELECT ROUND(10.499, 1) FROM DUAL; -- 10.5

SELECT ROUND(10.499, 2) FROM DUAL; -- 10.50

SELECT ROUND(10.493, 2) FROM DUAL; -- 10.49

SELECT ROUND(55.993, -1) FROM DUAL; -- 60

SELECT ROUND(55.493, -2) FROM DUAL; -- 100
 
SELECT ROUND(555.993, -2) FROM DUAL; -- 600

SELECT ROUND(575.993, -3) FROM DUAL; -- 1000


SELECT ROUND(475.993, -3) FROM DUAL; -- 0


SELECT ROUND(1470.993, -2) FROM DUAL; -- 1500


-------------------- trunc FUNCTION  -----------------------------------------  

SELECT TRUNC(10.6565) FROM DUAL; -- 10

SELECT TRUNC(10.6565, 2) FROM DUAL; -- 10.65

SELECT TRUNC(988.6565, -2) FROM DUAL; -- 900

SELECT TRUNC(9998.6565, -2) FROM DUAL; -- 9900

SELECT TRUNC(9998.6565, -3) FROM DUAL; -- 0

-- MOD FUNCTION
-- RETUEN THE REMAINDER OF DEVISION

SELECT MOD(15,2) FROM DUAL; -- 1

SELECT MOD(15,3) FROM DUAL; -- 0


-------------------------- DATE FUNCTION -------------------------------

-- RR FORMAT 
	-- IN GENERAL IF THE VALUE BETWEEN 50-90 THIS RETURN A 19xx YEAR
	-- A VALUE BETWEEN 0-49 WILL RETURN A 20XX YEAR


-- SYSDATE
-- SYSDATE IS A FUNCTION THAT RETURN THE CURENT DATABASE SERVER DATA AND TIME
	 SELECT SYSDATE FROM DYAL;


-- USING ARITHMETIC OPERATORS WITH DATES

-- DATE +  NUMBER = DATE

SELECT SYSDATE, SYSDATE + 3 FROM DUAL; -- ADDING DAYS

--  DATE - NUMBER = DATE

SELECT SYSDATE, SAYSDATE - 3 FROM DUAL;


-- DATE - DATE = NUMBER OF DAYS 

SELECT EMPLOYEES_ID, SYSDATE, SYSDATE-HIRE_DATE, ROUND(SYSDATE-HIRE_DATE)
FROM EMPLOYEES;

-- DATE + NUMBER/24 = ADDING NUM OF HOURS TO DATE

SELECT SYSDATE+ 5/24 FROM DUAL; -- NEXT LESSON WE WILL KNOW TO SHOW IT

-- EXAMPLE : I NEED HOW MANY WEEKS THE EMPLOYEES 'ADAM' WORK TILL NOW

SELECT EMPLOYEE_ID, FIRST_NAME, SYSDATE-HIRE_DATE "NO OF DAYS" , (SYSDATE-HIRE_DATE)/7
FROM EMPLOYEES
WHERE FIRST_NAME = 'ADAM';

-- MONTH
-- MONTH_BETWEEN

SELECT EMPLOYEE_ID, FIRST_NAME, MONTHS_BETWEEN(SYSDATE, HIRE_DATE), (SYSDATE-HIRE_DATE)/30
FROM EMPLOYEES;

--- NOTE THAT MONTHS_BETWEEN MORE ACCURATE THAN NUMBER OF DAYS/30

-- NOTE IF THE DATE1 LESS THAN DATE 2, THE RESULT BECOME NEGATIVE

SELECT EMPLOYEE_ID, FIRST_NAME, MONTHS_BETWEEN(HIRE_DATE,SYSDATE)
FROM EMPLOYEES;

-- ADD_MONTH

SELECT EMPLOYEE_ID, FIRST_NAME,HIRE_DATE, ADD_MONTHS(HIRE_DATE,4)
FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME,HIRE_DATE, ADD_MONTHS(HIRE_DATE,-2)
FROM EMPLOYEES;

--- NEXT_DAY

SELECT SYSDATE,NEXT_DAY(SYSDATE,'FRIDAY') FROM DUAL;

SELECT SYSDATE,NEXT_DAY(SYSDATE,1) FROM DUAL; -- OR YOU CAN ENTER NUMBER FROM 1 TO 2

-- NOTE THAT 1='MONDAY' AND CONTINUE TILL 7 

-- LAST_DAY

SELECT LAST_DAY(SYSDATE) FROM DUAL;

-- EXAMPLE

/* dispaly the employee number, first_name, hire_date, number of months employeed,
six month review date, first friday after hire date
for all employees who have employeed for fewer than 100 months */

SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, MONTHS_BETWEEN(SYSDATE, HIRE_DATE),
ADD_MONTHS(HIRE_DATE,6) , NEXT_DAY(HIRE_DATE,'FRIDAY')
FROM 
EMPLOYEES
WHERE MONTHS_BETWEEN(SYSDATE,HIRE_DATE)<100;

-- ROUND  AND TRUNC

SELECT EMPLOYEES_ID, FIRST_NAME, HIRE_DATE,
ROUND(HIRE_DATE, 'MONTH'), TRUNC(HIRE_DATE, 'MONTH')
FROM EMPLOYEES
ORDER BY HIRE_DATE;

SELECT EMPLOYEES_ID, FIRST_NAME, HIRE_DATE,
ROUND(HIRE_DATE, 'YEAR'), TRUNC(HIRE_DATE, 'YEAR')
FROM EMPLOYEES
ORDER BY HIRE_DATE;

---- NESTED FUNCTIONS -------------------


SELECT FIRST_NAME,UPPER(FIRST_NAME), SUBSTR(UPPER(FIRST_NAME),1,3),
LPAD(SUBSTR(UPPER(FIRST_NAME),1,3),10,'*')
FROM EMPLOYEES;


-- CONVERSION FUNCTION

 -- TO_CHAR WITH DATES

 SELECT TO_CHAR(SYSDATE,'DD.MM.YYYY') FROM DUAL;
 SELECT TO_CHAR(SYSDATE,'DD-MM-YYYY HH:MI:SS PM') FROM DUAL; -- AM AND PM ARE THE SAME
 SELECT TO_CHAR(SYSDATE, 'DD-MM-YYYY HH24:MI:SS PM') 

